## დავალების სრული აღწერა

**მოკლე მიმოხილვა**

დავალების მთავარი მიზანია **React**-ის ფრონტენდსა და **Node.js**-ის ბექენდზე (ორივე TypeScript-ით)
დაფუძნებული დინამიკური, მრავალეტაპიანი ფორმის შექმნა, სადაც ველები განისაზღვრება ბაზიდან.
პროექტი უნდა უზრუნველყოფდეს, რომ ფორმის ეტაპების ან ველების ცვლილება მომხმარებელთან აისახებოდეს ფორმის
გაგზავნის შემდეგაც, თუკი მონაცემები აღარ გადიან განახლებული ფორმის ვალიდაციას.

---

## ძირითადი მოთხოვნები

1. **Back-end**:

   - გამოიყენეთ **Node.js** და TypeScript.
   - სიმარტივისთვის, მონაცემთა შენახვისთვის გამოიყენეთ JSON ფაილები (არ გამოიყენოთ კლასიკური მონაცემთა ბაზა).
   - გამოიყენეთ შემდეგი JSON ფაილები:
     - **cities.json** – ქალაქების სია
       ```json
       [
         { "id": 1, "name": "Tbilisi" },
         { "id": 2, "name": "Kutaisi" }
       ]
       ```
     - **schools-1.json** – სკოლების სია ქალაქისთვის id=1
       ```json
       [
         { "id": 1, "name": "School N10" },
         { "id": 3, "name": "School N145" },
         { "id": 4, "name": "School N53" }
       ]
       ```
     - **schools-2.json** – სკოლების სია ქალაქისთვის id=1
       ```json
       [
         { "id": 2, "name": "School N7" },
         { "id": 5, "name": "School N1" }
       ]
       ```
     - **form.json** – ფორმის სტრუქტურა, რომელიც განსაზღვრავს რამდენი ეტაპია/ნაბიჯია (steps) და თითოეულ ნაბიჯზე რა ველები (fields) უნდა გამოვიყენოთ:
       ```json
       [
         {
           "title": "Step 1",
           "fields": [
             {
               "prop": "name",
               "label": "First name",
               "placeholder": "Example: Elon",
               "type": "input",
               "validation": {
                 "type": "string",
                 "minLength": 2,
                 "required": true
               }
             },
             {
               "prop": "surname",
               "label": "Last name",
               "placeholder": "Example: Musk",
               "type": "input",
               "validation": { "type": "string", "minLength": 2 }
             },
             {
               "prop": "city",
               "label": "City",
               "placeholder": "Choose city",
               "type": "select",
               "collection": "cities",
               "allowCustomInput": false,
               "validation": { "type": "number", "required": true }
             },
             {
               "prop": "school",
               "label": "School",
               "placeholder": "Choose school",
               "type": "select",
               "collection": "schools",
               "allowCustomInput": true,
               "customInputOption": "My school isn't in the list",
               "validation": { "type": "number", "required": true },
               "customInput": {
                 "label": "Name",
                 "placeholder": "enter here",
                 "validation": {
                   "type": "string",
                   "minLength": 1,
                   "required": true
                 }
               }
             }
           ]
         },
         {
           "title": "Step 2",
           "fields": [
             {
               "prop": "age",
               "label": "Age",
               "placeholder": "Example: 18",
               "type": "input",
               "subType": "number",
               "validation": { "type": "number", "min": 18 }
             },
             {
               "prop": "mail",
               "label": "E-mail",
               "placeholder": "example@gmail.com",
               "type": "input",
               "subType": "email",
               "validation": { "type": "email", "required": true }
             },
             {
               "prop": "password",
               "label": "Password",
               "placeholder": "",
               "type": "input",
               "subType": "password",
               "validation": {
                 "type": "string",
                 "minLength": 8,
                 "required": true
               }
             },
             {
               "prop": "password",
               "label": "Password",
               "placeholder": "",
               "type": "input",
               "subType": "password",
               "validation": { "type": "number", "min": 18, "required": true }
             },
             {
               "prop": "termsAndConditions",
               "label": "I agree to the terms and conditions",
               "placeholder": "",
               "type": "checkbox",
               "validation": {
                 "type": "boolean",
                 "validValues": [true],
                 "required": true
               }
             }
           ]
         }
       ]
       ```

2. **Front-end**:

   - გამოიყენეთ **React** (TypeScript-ით).
   - გამოიყენეთ **react-hook-form** ფორმის ველების სამართავად.

3. **Endpoint-ები ბექენდში**:
   1. `GET /cities` – აბრუნებს `cities.json`-ში მითითებულ ქალაქებს.
   2. `GET /schools?cityId=<id>` – აბრუნებს შესაბამისი ქალაქის სკოლებს, მაგალითად `schools-1.json` ან `schools-2.json`-დან.
   3. `GET /form` – აბრუნებს `form.json`-ში მითითებულ ინფორმაციას (ნაბიჯები, ველები, ვალიდაციის წესები და ა.შ.).
   4. `POST /submit` – იღებს შევსებულ ფორმის მონაცემს, ამოწმებს ვალიდაციას `form.json`-ის უახლესი ვერსიის მიხედვით და აბრუნებს შედეგს (ხარვეზების სიას დაფიქსირების შემთხვევაში ან წარმატების მესიჯს).

---

## ფუნქციონალის დეტალური აღწერა

1. **მრავალეტაპიანი ფორმა**:

   - მომხმარებელს პირველად გამოუჩნდება პირველი ნაბიჯი (`Step 1`), შეჰყავს ველებში მონაცემები და შეუძლია გადაინაცვლოს **შემდეგ ეტაპზე** ან დაბრუნდეს **წინა ეტაპზე**.
   - ყოველი ნაბიჯის ჩამთავრებისას (Next step ღილაკზე დაჭერისას) უნდა ხდებოდეს ფრონტენდზე ვალიდაცია. თუ რომელიმე ველი შეცდომითაა შევსებული, სისტემა უნდა ფოკუსირდეს პირველვე ველზე, სადაც შეცდომა დაფიქსირდა, და შეცდომით შევსებული ყოველი ველის ქვეშ გამოიტანოს შესაბამისი ერორ მესიჯი. მაგალითად, თუ `name` და `surname` მინიმუმ 2 სიმბოლოს ითხოვს და ორივე ცარიელია, გამოისახება **"Min 2 characters required"** შეტყობინება ორივეს ქვეშ, და დაფოკუსირდება პირველ ველზე (`name`-ზე).
   - ბოლო ნაბიჯზე Next step-ის ნაცვლად ჩანს "Submit" ღილაკი. ფორმის შევსებისას ღილაკზე "Submit" დაჭერისას, თუკი ფრონტზე ვალიდაცია წარმატებულია, ხდება საბოლოო გაგზავნა ბექენდზე (მთელი მონაცემების ერთიანად).

2. **ველების ტიპები**:

   - `type: "input"` – ჩასაწერი ველი (`subType`-ის მნიშვნელობამ შეიძლება ჩააზუსტოს კონკრეტული ტიპი: "number", "email" ან "password").
   - `type: "select"` – ჩამოსაშლელი მენიუ, რომლის მონაცემებიც მიიღება ბექისგან.
     - თუ ველში განსაზღვრულია `allowCustomInput: true`, მაშინ ჩამოსაშლელში გამოჩნდება დამატებითი არჩევანი - `customInputOption` (მაგ., **"My school isn't in the list"**), რომლის არჩევის შემთხვევაშიც უნდა გამოჩნდეს ახალი ტექსტური ველი (`customInput`).
   - `type: "checkbox"` – Checkbox, რომელსაც შეიძლება ჰქონდეს ვალიდაცია, მაგალითად **"validValues": [true]** ნიშნავს, რომ ჩექბოქსის მონიშვნა აუცილებელია შემდეგ ეტაპზე გადასასვლელად (ან ბოლო ეტაპის შემთხვევაში - დასასაბმითებლად).

3. **დინამიკური ჩატვირთვა**:

   - ფრონტმა select-ის options უნდა მოითხოვოს მხოლოდ მაშინ, როდესაც ეს ველი რეალურად ჩანს ფორმაზე. თუკი, მაგალითად, `city` ველი გვხვდება მესამე ეტაპზე, მონაცემების ჩატვირთვა უნდა მოხდეს მხოლოდ იმ მომენტში, როდესაც მომხმარებელი მიაღწევს მესამე ეტაპს.
   - სკოლების სია კი უნდა მოითხოვოს მხოლოდ ქალაქის არჩევის მერე. ბექმა უნდა დააბრუნოს შესაბამისი ქალაქის სკოლების სია.
   - ასეთი სიების ჩატვირთვისას თუ მოხდა შეცდომა, ფრონტენდზე უნდა გამოჩნდეს ხეხალხლა ცდის, **Retry**-ის, ღილაკი; Retry-ზე დაჭერისას უნდა გამოერდეს რიქუესთი.
   - სანამ მონაცემები იტვირთება, მომხმარებელი რამე სახით უნდა ხედავდეს, რომ იტვითება მონაცემები. ასევე ამ დროს შემდეგ ეტაპზე გადასასვლელი ღილაკი (ან ბოლო ეტაპზე - დასაბმითებულის ღილაკი) უნდა იყოს disabled.

4. **ვალიდაცია და შეცდომების დამუშავება**:

   - ვალიდაცია ხდება როგორც ფრონტენდზე, ასევე შევსებული ფორმის მონაცემების გაგზავნისას – ბექენდზე.
   - `POST /submit` ენდფოინთის დატვირთვა:
     - ველი, რომელსაც `type: "string"`, "number"` ან "boolean"` უწერია, უნდა შეამოწმოს, ნამდვილად მიესადაგება თუ არა შესაბამის ტიპს.
     - `type: "email"`-ის შემთხვევაში მოწმდება, სწორი ფორმატის თუა მეილი.
     - `minLength`, `min`, `required`, `validValues` და სხვა მსგავსი პირობებიც უნდა შემოწმდეს.
     - შესაძლოა, მას შემდეგ, რაც ფრონტმა მოითხოვა ფორმის კონფიგურაცია, დასაბმითებამდე ის შეიცვალოს, ამიტომ ბექენდი ყოველთვის უახლეს `form.json`-ს ეყრდნობა.
   - თუ ერთი შეცდომა მაინც ფიქსირდება, ბექენდი აბრუნებს **ყველა ველის შეცდომების სიას**.
   - როგორც კი ბექენდი ვალიდაციის შეცდომას აბრუნებს, ფრონტენდი იღებს პასუხს შეცდომების შესახებ და ხელახლა ითხოვს უახლესი ფორმის კონფიგურაციას. შემდეგ:
     - ეკრანზე ბრუნდება პირველივე ეტაპი, სადაც არის რამე შეცდომა მაინც;
     - აფოკუსებს პირველ ველს, სადაც შეცდომა ფიქსირდება;
     - უკვე არარელევანტური ველები (თუ წაიშალა ველი `form.json`-იდან) აღარ გამოჩნდება და მათი მნიშვნელობები დასაბმითებისას აღარ იგზავნება, ხოლო დარჩენილ ველებში მომხმარებლის შეყვანილი მონაცემები შენარჩუნდება;
     - ახალი ველები გამოჩნდება შესაბამის ეტაპზე;
     - თავისთავად, თუ რაიმე ახალი ეტაპი დაემატა, ხელმისაწვდომი უნდა იყოს ეს ეტაპიც;

5. **შედეგი**:
   - თუ საბოლოო გაგზავნისას ბექენდის ვალიდაცია წარმატებით დასრულდა, მომხმარებელს უნდა გამოუჩნდეს **წარმატების შეტყობინება** (Success message) ფორმის ნაცვლად.

---

## ტექნიკური შენიშვნები

1. სიმარტივისთვის კლასიკური მონაცემთა ბაზის **ნაცვლად** გამოიყენეთ მოცემული JSON ფაილები. ბექენდს შეუძლია პირდაპირ წაიკითხოს ეს ფაილები. სურვილისამებრ შეგიძლიათ მათი შეცვლა. ცვლილება შეგიძლიათ ხელით. არ არის საჭირო, ბექენდში დაიწეროს რაიმე კოდი მათ შესაცვლელად.
2. ფრონტში ველების სამართავად გამოიყენეთ **react-hook-form** ბიბლიოთეკა.
3. **დამატებითი ბიბლიოთეკები**:
   - თუ გამოიყენებთ რაიმე UI ბიბლიოთეკას, გამოიყენეთ მხოლოდ საქმის გასამარტივებლად (მაგალითად უფრო მოქნილი select კომპონენტისთვის), რადგან დიზაინს ყურადღება არ მიექცევა.
   - ისეთი გავრცელებული ბიბლიოთეკებისთვის, როგორიცაა `vite`, `express` ან `axios`, გამოყენების დასაბუთება საჭირო არ არის. დანარჩენებისთვის დაწერეთ დასაბუთება, რატომ გამოიყენეთ.

---

### მაგალითი, რა სახის ინფორმაცია შეიძლება გაგზავნოს ფრონტენდმა საბოლოოდ (დასაბმითებისას):

```json
{
  "name": "Nick",
  "surname": "Fury",
  "city": 1,
  "school": "School of S.H.I.E.L.D.",
  "age": null,
  "mail": "nick.fury@marvel.com",
  "password": "captMarvel",
  "termsAndConditions": true
}
```

## დავალების შესრულება და შეფასება

1. შექმენით რეპოზიტორია github-ზე.
2. შეასრულეთ ძირითადი მოთხოვნები და ფუნქციონალის დეტალური აღწერის პუნქტები.
3. შეფასებისას დიზაინს **არ მიექცევა** ყურადღება.
4. ყურადღება მიექცევა:

- მოქნილობას (რამდენად მარტივი იქნება ახალი მოთხოვნის დამატება კოდებში);
- კოდის სისუფთავეს;
- თუ რამდენად სრულდება ფუნქციონალის ყველა დეტალი (ამიტომ ნებიმისერი ბუნდოვნების შემთხვევაში არ მოგერიდოთ, მომწეროთ და დააზუსტოთ პირობა);
- ხარვეზების ნაკლებობას;
- loading და error handling რამდენად კარგადაა გამართული;

5. მუშაობისას შეგიძლიათ გამოიყენოთ ყველა ონლაინ რესურსი, იქნება ეს Google, stackoverflow თუ AI მოდელები. მეტიც, რეკომენდებულია, გამოიყენოთ ეგ უკანასკნელი.

---
